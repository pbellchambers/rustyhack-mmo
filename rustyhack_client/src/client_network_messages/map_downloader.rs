use bincode::config::Configuration;
use bincode::{borrow_decode_from_slice, config, encode_to_vec};
use message_io::network::{NetEvent, Transport};
use message_io::node;
use message_io::node::NodeEvent;
use rustyhack_lib::background_map::AllMaps;
use rustyhack_lib::network::packets::{PlayerRequest, ServerMessage};
use std::collections::HashMap;
use std::process;

pub(crate) fn request_all_maps_data(server_tcp_addr: &str) -> AllMaps {
    let mut all_maps = HashMap::new();
    let (handler, listener) = node::split();

    //connect to server tcp port
    let (server, _) = handler
        .network()
        .connect(Transport::FramedTcp, server_tcp_addr)
        .unwrap_or_else(|err| {
            error!(
                "Unable to connect to server {}, error: {}",
                &server_tcp_addr, err
            );
            process::exit(1);
        });

    //send GetAllMaps request and wait for response
    listener.for_each(|event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => {
                info!("Sending GetAllMaps request to server.");
                handler.signals().send(PlayerRequest::GetAllMaps);
            }
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                info!("Received raw AllMaps data from server.");
                let all_maps_option = decode_all_maps_reply(data);
                match all_maps_option {
                    None => {
                        info!("Sending GetAllMaps request to server.");
                        handler.signals().send(PlayerRequest::GetAllMaps);
                    }
                    Some(all_maps_data) => {
                        all_maps = all_maps_data;
                        handler.stop();
                        handler.network().remove(server.resource_id());
                    }
                }
            }
            NetEvent::Disconnected(_endpoint) => {
                error!("Server is disconnected.");
                handler.stop();
                handler.network().remove(server.resource_id());
                process::exit(1);
            }
        },
        NodeEvent::Signal(signal) => match signal {
            PlayerRequest::GetAllMaps => {
                handler.network().send(
                    server,
                    &encode_to_vec(&PlayerRequest::GetAllMaps, config::standard()).unwrap(),
                );
            }
            _ => {
                warn!("Ignoring invalid PlayerRequest on tcp channel.");
            }
        },
    });
    all_maps
}

fn decode_all_maps_reply(data: &[u8]) -> Option<AllMaps> {
    let decoded_data =
        borrow_decode_from_slice::<ServerMessage, Configuration>(data, config::standard());
    match decoded_data {
        Ok(decoded) => {
            if let ServerMessage::AllMaps(all_maps) = decoded.0 {
                info!("AllMaps data downloaded successfully.");
                Some(all_maps)
            } else {
                warn!(
                    "Decoded message from server was not valid AllMaps data, will request again."
                );
                None
            }
        }
        Err(error) => {
            error!(
                "Error decoding AllMaps from server, will request again. {}",
                error.to_string()
            );
            None
        }
    }
}
